\documentclass{new_tlp}
\input pheader18.tex

\begin{document}

%\title[A Unified View of (Lazy) Generators in Prolog]{All Rivers Flow to The Sea: A Unified %View of (Lazy) Generators in Prolog}

\title{Lazy Stream Programming in Prolog}

%\begin{comment}
\author[Paul Tarau, Jan Wielemaker, Tom Schrijvers and Koen Pauwels]
          {    Paul Tarau\\
%          Dept. of Computer Science and Engineering 
%          \\ University of North Texas\\
%          1155 Union Circle, Denton, Texas 76203, USA\\
          { paul.tarau@unt.edu}
          \and
          Jan Wielemaker\\
          { J.Wielemaker@vu.nl}
          \and
          Tom Schrijvers\\
          { tom.schrijvers@cs.kuleuven.be}
          \and
          Koen Pauwels\\
          { koen.pauwels@cs.kuleuven.be}
}          
%\end{comment}

\maketitle



\begin{abstract}
In recent years, stream processing has become a prominent approach for incrementally handling large amounts of data, with special support and libraries in many programming languages. Unfortunately, support in Prolog has so far been lacking and most existing approaches are ad-hoc. To remedy this situation, we present {\em lazy stream generators} as a unified Prolog interface for stateful computations on both finite and infinite sequences of data that are produced incrementally through I/O and/or algorithmically.

We expose stream generators to the application programmer in two ways: 1) through an abstract sequence manipulation API, convenient for defining custom generators, and 2) as idiomatic lazy lists, compatible with many existing list predicates.  We define an algebra of stream generator operations that extends Prolog via an embedded language interpreter, provides a compact notation for composing generators and supports moving between the two isomorphic representations.

As a special instance, we introduce answer stream generators that encapsulate the work of coroutining first-class logic engines and support interoperation between forward recursive {\em AND-streams} and backtracking-generated {\em OR-streams}. 

{\bf Keywords:}
lazy stream generators,
lazy lists,
first-class logic engines,
stream combinators,
AND-stream/OR-stream interoperation,
Prolog extensions

\end{abstract}

\begin{comment}
\begin{abstract}
Lazy stream generators provide a unified interface to stateful computations, I/O operations as well as algorithms producing finite or infinite sequences. 

As a special instance, we introduce answer stream generators that 
encapsulate the work of coroutining first-class logic engines and support interoperation between forward recursive {\em AND-streams} and backtracking-generated {\em OR-streams}. 

Stream generators are exposed to the application programmer either through an abstract sequence manipulation API or as lazy lists. We define an algebra of stream generator operations that extends Prolog via an embedded language interpreter providing a compact notation for composition mechanisms and supports moving between isomorphic sequence representations.
\end{abstract}
\end{comment}


\section{Introduction}

Initial design as well as evolution of successful programming languages often walks a fine line between semantic purity and pragmatic expressiveness. With its declarative roots and creative pragmatic additions Prolog is a long-time survivor in the complex ecosystem of programming languages. We believe that its longevity is due not only to its elegant semantics but also to its creative adaptations to emerging programming language features that respond to evolving software development requirements.

Stream processing, now prevalent in widely used programming languages languages like Java, Python, C\# or JavaScript offers a uniform and (mostly) declarative view on processing finite 
and infinite\footnote{We use ``infinite'' here as a short hand qualifier for data or computation streams of unpredictable, large or very large size.} sequences. Arguably, its advent has been driven, besides the expressiveness lift it provides, by the need of processing big data. This big data problem manifests itself in static incarnations like very large training sets for machine learning, or as dynamic event streams coming from Web search queries and clicks,  or from sensor networks supporting today's fast spreading IOT infrastructure.
 
Several techniques have been used to extend mature programming languages with stream processing. The task has been facilitated by the presence of generalized iterator constructs like Python's generators or by presence of lazy evaluation semantics in functional languages. To extend Prolog with state-of-the-art lazy stream processing capabilities, a few limitations need to be overcome.

The first limitation is that Prolog's resolution mechanism is subject to a fixed depth-first search and a strict evaluation semantics.
While Prolog's depth-first  search mechanism can be complemented with alternative search strategies as shown in \cite{tor} by overriding its disjunction operator, the evaluation mechanism remains ultimately eager. When programming with lists or DCGs, one chains recursive steps
in the body of clauses connected by conjunctions. 

The second limitation, consequence of Prolog's incremental evolution as a programming language, is the presence of procedural state-management and I/O constructs that are
interleaved with its native declarative programming constructs. These range form 
random generator streams to file and socket I/O and dynamic database operations.
While monadic constructs in functional languages \cite{moggi:monads,wadler93:cont}  can provide  a unified view of declarative and procedural state-management operations, logic programming languages still lack a unified approach providing a uniform interface to 
this mix of declarative and procedural language constructs.

A key step in this direction is SWI-Prolog's \cite{swi} {\em lazy\_lists} library \cite{lazy_lists}.
 It uses, ``under the hood'', attributed variables and destructive updates  to provide a declarative view of such state transformers in terms of the list unification steps familiar to the Prolog programmer. 
At the same time, it makes sense to expose stream generators as abstract sequence-manipulation operators, independent of the specific list representation of
possibly infinite, lazily produced streams coming from I/O operations, coroutining logic engines or some complex computations that one might want to declaratively aggregate into an algebra of stream combinators.


This brings us to the main goals of this paper. 
We encapsulate stream processing extensions to Prolog that use
state transformers, lazy lists and first-class logic engines 
%\cite{tarau:parimp99,tarau:cl2000,iclp08:inter,ciclops08:pINTER,bp2011},
\cite{tarau:cl2000,bp2011}, recently added to SWI-Prolog \cite{swi_engines},
into a set of operations organized compositionally in the form of {\em 
stream generators}.
Our generators are similar to Python's {\em yield} mechanism \cite{beazley09} and 
they share features with coroutining constructs now present in a several other widely used programming languages including C\#, Javascript and Lua. At the same time, 
they lift Prolog's expressiveness with lazy evaluation mechanisms similar to non-strict
functional programming languages like Haskell \cite{hudak07} or functional-logic languages like Curry \cite{antoy05}.

We organize our generators as an algebra, wrapped as a library module with a declarative interface, to avoid exposing  operations requiring an implementation with a clear procedural flavor to the Prolog application programmer.

By defining an iso-functor that transports operations between
generators and lazy lists, we offer a choice between 
abstract sequence operations and the concrete list view familiar to Prolog users.

Our implementation of lazy streams is available as a SWI Prolog package at:\\
{\small \url{https://github.com/ptarau/AnswerStreamGenerators/raw/master/lazy_streams-0.5.0.zip } }

The main contributions of this paper are:
\BI
\I a simple and clean approach for setting up lazy streams
\I a lazy list representation of lazy streams to naturally use them as Prolog lists
\I a library of lazy stream sources, transformers and combinators %and sinks
%  (or two libraries if we are counting the lazy\_lists library)
\EI

The paper is organized as follows.

{\Large TODO}

\section{Overview}

{\Large
     Show small examples of the use of lazy streams to give an idea of their expressive power and how neat the code looks
 }
     
     
\section{Implementation}
     
\subsection{The Stream Generator Interface}

Generators are built by a family of constructors, encapsulating sequences produced algorithmically or as a result of state transformers interfacing Prolog with the ``outside world'', a design philosophy similar to that of monads in functional languages.

The ``contract'' is that a generator, defined by a closure that moves it one step further is called by the {\tt ask/2} predicate, defined as follows:
\begin{code}
ask(E,_):-is_done(E),!,fail.
ask(E,R):-call(E,X),!,R=X.
ask(E,_):-stop(E),fail.
\end{code}
Note also the checking for terminated generators by {\tt is\_done/1} and the explicit termination by {\tt stop/1} on failure.

The single advancement steps provided by {\tt ask/2} can be morphed into an answer stream generated on backtracking with the infix predicate {\tt in/2}.
\begin{code}
:-op(800,xfx,(in)).

X in Gen:-ask(Gen,A),select_from(Gen,A,X).

select_from(_,X,X).
select_from(Gen,_,X):-X in Gen.
\end{code}

The simplest generator is the infinite constant stream producer {\tt const/2}:
\begin{code}
const(Constant, Generator)
\end{code}
that when {\tt ask/2} asks for the next element with
\begin{codex}
call(=(Constant),X)
\end{codex}
it will simply unify {\tt X} and {\tt Constant}.

Another one, relying on externally maintained state is {\tt rand/1}.
\begin{code}
rand(random()).
\end{code}
This generator will, when called by {\tt ask/2}, produce a stream of random floating point numbers between 0 and 1.

A generic constructor for a stream evolving by incremental state changes is
\begin{code}
gen_next(F,State,X):-
  arg(1,State,X),
  call(F,X,Y),
  nb_setarg(1,State,Y).
\end{code}
where {\tt State} acts a container for destructively updated values.


%\subsection{Generators as Simple State Transformers}

In terms of {\tt gen\_next} the stream of natural numbers is defined as:
\begin{code}
nat(nat_next(state(0))).

nat_next(S,X):-gen_next(succ,S,X).
\end{code}

Generators for which state update and value yield are distinct
can be obtained as specializations of {\tt gen\_nextval/3}.
\begin{code}
gen_nextval(Advancer,State,Yield):-
  arg(1,State,X1),
  call(Advancer,X1,X2, Yield),
  nb_setarg(1,State,X2).
\end{code}

For instance, by using {\tt gen\_nextval} one can turn a list into a generator of its elements  in the form of the {\tt list/2} generator constructor.
\begin{code}
list(Xs, gen_nextval(list_step,state(Xs))).

list_step([X|Xs],Xs,X).
\end{code}

\BX
Using some simple generators.
\begin{codex}
?- nat(N),X in N.
N = nat_next(state(1)), X = 0 ;
N = nat_next(state(2)), X = 1 ;
N = nat_next(state(3)), X = 2 .
...

?- list([a,b,c],L),X in L.
L = gen_nextval(list_step, state([b, c])), X = a ;
L = gen_nextval(list_step, state([c])), X = b ;
L = gen_nextval(list_step, state([])), X = c ;
false.
\end{codex}
\EX

We have built similar stream generators in the library package 
{\tt lazy\_streams}, for a range of numbers, turning a finite list into
a an infinite cycle of its elements, as well as stream 
transformers excising a finite slice of a larger, possibly infinite stream,
and taking or dropping an initial segment of a stream.

\subsection{Answer Stream Generators}

When more complex computations are involved, that are cannot be expressed as step-by-step state transformations, a more powerful mechanism is needed. We will use generator constructors based on first class logic engines in this case, but we will expose their workings in terms of the same interface.

\subsubsection{SWI Prolog's engine implementation}

A first-class logic engine \cite{tarau:cl2000,bp2011} can be seen as a Prolog virtual machine that has its own stacks and machine state. 
In their SWI-Prolog implementation, unlike normal Prolog threads \cite{swi,swi_threads} though, they are not associated with an operating system thread. Instead, you ask an engine for a next answer with the predicate {\tt engine\_next/2}. Asking an engine for the next answer attaches the engine to the calling operating system thread and cause it to run until the engine calls {\tt engine\_yield/1} or its associated goal completes with an answer, failure or an exception. After the engine yields or completes, it is detached from the operating system thread and the answer term is made available to the calling thread. Communicating with an engine is similar to communicating with a Prolog system though the terminal. Engines are created with the built-in {\tt engine\_create/3} that uses a goal and and answer template as input and returns and engine handle as output. SWI-Prolog engines are created with minimal dynamic stack space and are garbage collected when unreachable.

Implementing the engine API does not assume that a Prolog system supports multi-threading, It only assumes that the virtual machine is fully reentrant, it can be queried and it can stop, yield data and resumes execution as a coroutine.

\begin{comment}
As Prolog virtual machines, engines have  an internal state. Thus interacting with them requires a concise and expressive, but ultimately procedural API. This is not very different from what working with attributed variables, instrumental to adding constraint solvers, requires.
\end{comment}

\subsection{Answer Stream Generator Constructors}

We design Answer Stream Generators as a wrapper around the SWI-Prolog engine implementation.
We can also keep the goals and answer templates that started the engine to make them reusable. At the same time this external wrapper ensures that engines stay garbage collectable on termination.

The constructor {\tt eng/3} creates a generator as a wrapper around
the {\tt engine\_next(Engine,Answer)} built-in.
\begin{code}
eng(X,Goal,engine_next(Engine)):-engine_create(X,Goal,Engine). 
\end{code}
A variant {\tt ceng/3} is also available if one wants to preserve
the goal and answer template, usable, for instance, to clone
the engine's answer stream, 
operation that makes sense when the Prolog code it is based on 
is free of side effects.

\subsection{The AND-stream / OR-stream Duality}

We call {\em AND-stream / OR-stream duality} the
ability to generate the same answer stream via backtracking (OR-streams) or
as part of a forward moving recursive loop (AND-streams).
As the examples that follow will show,
being oblivious to the choice of generation method they encapsulate,
is a key contributor to the ``expressiveness lift'' answer stream
generators bring to Prolog.

An example of {\em AND-stream} is  implemented
by the generator {\tt and\_nat\_stream}. 
It defines the infinite stream of natural numbers 
by yielding an answer at each step of a recursive loop.
\begin{code}
and_nat_stream(Gen):-eng(_,nat_goal(0),Gen).

nat_goal(N):-
  SN is N+1,
  engine_yield(N),
  nat_goal(SN).
\end{code}

Alternatively, one could define 
an equivalent generator as an OR-stream,  with answers 
produced via  backtracking.
\begin{code}
or_nat_stream(Gen):-eng(N, between(0,infinite,N), Gen).
\end{code}

When using engines, 
both AND-streams and OR-streams can be infinite, as in the
case of the generators {\tt and\_nat\_stream} and {\tt and\_nat\_stream}.
While one can see backtracking over an infinite set of answers as
a ``naturally born'' OR-stream, the ability of the generators to
yield answers from inside an infinite recursive loop is critical
for generating infinite AND-streams.

Note also that generating an answer stream by either of the above methods
is immaterial to the user of the generator which can be seen as a ``black box''.

\subsection{The Lazy List View of Prolog Streams}

{\Large TODO: add here Jan's description}

   Explain that we can use lazy lists like Prolog lists:
   \BI
   \I
    show examples of use
   \I show how the representation works
 \EI
 
 \begin{code}
%! lazy_nats(-LazyListOfNaturalNumbers)
%
% infinite lazy list of natural numbers
lazy_nats(L):-lazy_list(lazy_nats_next,0,L).

lazy_nats_next(X,SX,X):-succ(X,SX).
\end{code}
   
\subsection{The Operational Equivalence between Answer Stream Generators and Lazy Lists}

\BI

   \I show how we can convert lazy streams to lazy lists (and back), i,e., the two representations are isomorphic
   \I explain the problem with eager maplist, show how we can transport a lazy maplist from streams and derive a specialized version


\EI

With help from SWI-Prolog's {\tt lazy\_lists} library, generators can be turned into finite or infinite (lazy) lists and vice-versa.
\begin{code}
%! gen2lazy(+Generator,-LazyLIst)  
%
% Turns a generator into a lazy list  
gen2lazy(E,Ls):-lazy_list(gen2lazy_forward,E,Ls).

% E manages its state, so we just pass it on
gen2lazy_forward(E,E,X):-ask(E,X).

%! lazy2gen(+LazyList, -Generator)
%
% Turns a lazy list into a generator.
% Note that list/2 actually just  works on lazy lists!
lazy2gen(Xs,E):-list(Xs,E).

\end{code}

One can lift this equivalence between data objects to one between predicates using them via higher-order constructs.

\begin{code}
% iso functors

%! iso_fun(+Operation,+SourceType,+TargetType,+Arg1, -ResultOfSourceType)
%
% Transports a predicate of arity 2 F(+A,-B) to a domain where
% an operation can be performed and brings back the result.
iso_fun(F,From,To,A,B):-
  call(From,A,X),
  call(F,X,Y),
  call(To,Y,B).

%! iso_fun(+Operation,+SourceType,+TargetType,+Arg1,+Arg2, -ResultOfSourceType)
%
% Transports a predicate of arity 2 F(+A,+B,-C) to a domain where
% an operation can be performed and brings back the result. 
% transports F(+A,+B,-C) 
iso_fun(F,From,To,A,B,C):- % writeln(iso_fun(F,From,To,A,B,C)),
  call(From,A,X),
  call(From,B,Y),
  call(F,X,Y,Z),
  call(To,Z,C).

%! iso_fun_(+Operation,+SourceType,+TargetType,+Arg1, -Res1, -Res2)
%
% Transports a predicate of arity 2 F(+A,-B,-C) to a domain where
% an operation can be performed and brings back the results. 
% transports F(+A,+B,-C) 
iso_fun_(F,From,To,A,B,C):- 
  call(From,A,X),
  call(F,X, Y,Z), % X in, Y,Z out 
  call(To,Y,B),
  call(To,Z,C).
\end{code}

\section{The Generator Algebra}
We start with the simpler case of finite generators.
 



\subsection{Operations on Finite or  Infinite Stream Generators}

In the case of possibly infinite generators, we  ask each generator for one answer inside a linear recursive loop. We ensure that termination only happens if both generators terminate.
\begin{code}
TODO
\end{code}

Designing the recursive loop for possibly infinite products
proceeds with a loop that will need to store finite initial 
segments of the generators as they grow into two lists, initially
empty.
\begin{code}
prod(E1,E2,engine(E,X,G)):-
  G=prod_goal(E1,E2),
  engine_create(X,G,E).

prod_goal(E1,E2):-
  ask_generator(E1,A),
  prod_loop(1,A,E1-[],E2-[]).
\end{code}

The algorithm, expressed by the predicate {\tt cart\_prod\_loop}
switches between generators while none of them is done.
After that, it keeps progressing the active generator 
for new pairs, including those selecting an element 
from the stored lists of the terminated generator.
\begin{code}
prod_loop(Ord1,A,E1-Xs,E2-Ys):-
  flip(Ord1,Ord2,A,Y,Pair),
  forall(member(Y,Ys),generate_answer(Pair)),
  ask_generator(E2,B),
  !,
  cart_prod_loop(Ord2,B,E2-Ys,E1-[A|Xs]).
prod_loop(Ord1,_A,E1-_Xs,_E2-Ys):-
  flip(Ord1,_Ord2,X,Y,Pair),
  X in E1,member(Y,Ys),
  generate_answer(Pair),
  fail.
\end{code}

The predicate {\tt flip/5} ensures correct order in a given pair
as  generators take turn being the active one in the recursive loop. 
\begin{code} 
flip(1,2,X,Y,X-Y).
flip(2,1,X,Y,Y-X).
\end{code}

\BX
Working with infinite sums and products. The slice/3 predicate (to be defined later) allows limiting output to a finite initial segment.
\begin{codex}
?- nat(N),nat(M),sum(N,M,E),slice(E,0,6,S),X in S,writeln(X),fail.
0
0
1
1
2
2
false.

?- nat(N),nat(M),prod(N,M,E),slice(E,0,6,S),X in S,writeln(X),fail.
0-0
1-0
1-1
0-1
2-1
2-0
false.
\end{codex}
\EX


With some care, one can define engine operations such that they work on both
finite and infinite Answer Stream Generators.

For instance, the convolution operation can be defined as follows.


{\Large add mathematical formula}

\begin{code}

conv(E1,E2,E):-
  new_generator(_,conv_loop(E1,E2,0,[],[]),E).

conv_loop(E1,E2,N,Xs,Ys):-
  succ(N,SN),
  ask_generator(E1,X),XXs=[X|Xs],
  ask_generator(E2,Y),YYs=[Y|Ys],
  ( nth0(I,XXs,A),
    K is N-I,
    nth0(K,YYs,B),
    generate_answer(A-B),
    fail
  ; true  
  ),
  conv_loop(E1,E2,SN,XXs,YYs).
\end{code}

It assumes the two input streams have the same length, but it terminates
when the shortest ends. 

\BX
Examples of convolution.
\begin{codex}
?- nat(N),nat(M),conv(M,N,C),take(6,C,D),XY in D,writeln(XY),fail.
0-0
1-0
0-1
2-0
1-1
0-2
false.

?- nat(N),list2generator([a,b,c],M),conv(M,N,C),XY in C,writeln(XY),fail.
a-0
b-0
a-1
c-0
b-1
a-2
false.
\end{codex}
\EX

\subsection{An embedded language interpreter for the algebra}

With our sum and product operations ready, we can proceed designing the embedded language
facilitation more complex forms of generator compositions.

\subsubsection{Working with Sets}

If generators work over sets rather than multisets or arbitrary sequences,
duplicates need to be removed. This can be done either by sorting (which has the advantage
of providing a canonical representation, but assumes finite streams) or by using  a built-in like {\tt distinct/2} which will also work with infinite generators (within the limits of actual memory available).

The predicate {\tt setify} wraps a generator to ensure it produces a set of answers, with duplicates removed.
\begin{code}
setify(E,SE):-new_generator(X,distinct(X,X in E),SE).
\end{code}
In fact, one could just apply the same modification to the goal of a generator and its answer template, but our assumption here is that the generator's engine might be a composition of several engine operations, possibly already in progress.

We can implement our generator algebra as an embedded language via a simple interpreter
(although partial evaluation can make this more efficient). We can also add {\tt !} as a unary prefix operator, used to mark a generator that needs to be cloned.

\begin{code}
:-op(100,fx,(!)).

eeval(engine(E,X,G),engine(E,X,G)).
eeval(!E,ClonedE):-clone_generator(E,ClonedE).
eeval(E+F,S):-eeval(E,EE),eeval(F,EF),dir_sum(EE,EF,S).
eeval(E*F,P):-eeval(E,EE),eeval(F,EF),cart_prod(EE,EF,P).
eeval({E},SetGen):-eeval(E,F),setify(F,SetGen).
eeval([X|Xs],E):-list2generator([X|Xs],E).
\end{code}
Similarly to the {\tt in/2} predicate, we can make the action of the
interpreter transparent, via the {\tt in\_/2} predicate, also defined as an operator.
\begin{code}
:-op(800,xfx,(in_)).
X in_ E:-eeval(E,EE),X in EE.     
\end{code}


\BX
Applying the embedded language interpreter.
\begin{codex}
?- list2generator([a,b],E),forall(X in_ E +(!E * !E), writeln(X)).
a
a-a
b
b-a
b-b
a-b
E = engine(<engine>(7,0x7fe9b80517a0), _2298, member(_2298, [a, b])).

?- forall(X in_ {[a,b] + [b,a]}, writeln(X)).
a
b
true.
\end{codex}

\EX
\subsection{Some algebraic properties of sums and products}

\BI
\I monoid structure for + and *
\I distributivity
\I commutativity and associativity if the generated sequences represent sets
\EI

\begin{code}
\end{code}

\section{Lazy Functional Programming Constructs}

\subsection{Map-reduce mechanisms}

The predicate {\tt map\_generator/3} creates a new generator that
applies a predicate with 2 arguments to the answer stream  of a generator.
\begin{code}
map_generator(F,E,NewE):-new_generator(Y,map_goal(F,E,Y),NewE).

map_goal(F,E,Y):-X in E,call(F,X,Y).
\end{code}

The predicate {\tt map\_generator/4} creates a new generator that
applies a predicate with 3 arguments to the answer stream  of a generator.
Note also that in case the answer-counts of the two streams are not the same, the one
still active is stopped to make it subject to garbage collection.
\begin{code}
map_generator(F,E1,E2,NewE):-new_generator(_,map_goal2(F,E1,E2),NewE).

map_goal2(F,E1,E2):-
  ( ask_generator(E1,X1)->Ok1=true;Ok1=fail),
  ( ask_generator(E2,X2)->Ok2=true;Ok2=fail),
  ( Ok1,Ok2->call(F,X1,X2,R),
    generate_answer(R),
    map_goal2(F,E1,E2)
  ; \+Ok1,Ok2->stop_generator(E2),fail
  ; Ok1,\+Ok2->stop_generator(E1),fail
  ).
\end{code}

The predicate {\tt zipper\_of} specializes {\tt map\_generator/4} to create
pairs of answers produced by the 2 generators.
\begin{code}
zipper_of(E1,E2,E):-map_generator(zip2,E1,E2,E).

zip2(X,Y,X-Y).
\end{code}
The predicate {\tt reduce\_with}, similar to {\tt fold} in functional languages
applies repeatedly an operation on the stream of answers of a generator.

It can be made to work in constant space, by
backtracking internally over a given generator.
\begin{code}
reduce_with(Op,E,R):-
  ask_generator(E,First),
  Res=result(First),
  ( Y in E,
    arg(1,Res,X),
    call(Op,X,Y,R),
    nb_setarg(1,Res,R),
    fail
  ; arg(1,Res,R)
  ).
\end{code}

It can be wrapped into a generator, to support our algebra of generators in a uniform way.

\begin{code}
reducer(Op,E,NewE):-new_generator(R,reduce_with(Op,E,R),NewE).
\end{code}

\BX
\begin{codex}
?- range(5,E),reducer(plus,E,NewE),X in NewE.
E = engine(<engine>(4,0x7ff879d64130), _3120, between(0, 4, _3120)),
NewE = engine(<engine>(3,0x7ff879d643f0), _3156, reduce_with(plus,
engine(<engine>(4,0x7ff879d64130), _3120, between(0, 4, _3120)), _3156)),
X = 10 ;
false.
\end{codex}
\EX
\BI
\I TODO mention here reducing a direct sum of generators with a min operation - e.g. for finding the best price among a stream of answers representing several vendors for the same product
\EI

\subsection{Slicing Operations on Answer Generators}
\begin{code}
slice(E,From,To,NewE):-new_generator(X,in_slice_of(E,From,To,X),NewE).

in_slice_of(E,From,To, X):-
  From>=0,From<To,
  Ctr=c(0),
  X in E,
  arg(1,Ctr,K),K1 is K+1,nb_setarg(1,Ctr,K1),
  (
    K<From->fail
  ; K>=To->stop_generator(E),!,fail
  ; true
  ).
  
take(K,E,NewE):-slice(E,0,K,NewE).

drop(K,E,NewE):-slice(E,K,inf,NewE).
\end{code}

As an example, putting it all together, let's generate Pythagorean natural numbers X,Y,Z such
that $X^2+Y^2=Z^2$.

\begin{code}
pythagoras(Triplets):-
  nat(M),
  nat(N),
  cart_prod(M,N,Pairs),
  map_generator(mn2xyz,Pairs,Triplets).
\end{code}
For efficiency, we will use here the parametric solutions
$X=M^2-N^2, Y=2MN, Z=M^2+N^2$.
\begin{code}
mn2xyz(M-N,X^2+Y^2=:=Z^2):-N>0,M>N,
  X is M^2-N^2,
  Y is 2*M*N,
  Z is M^2+N^2.
\end{code}
We can extract a sample of the stream by creating
a slice generator, together with an assertion testing its correctness as follows.
\begin{code}
pythagorean_slice:-
  pythagoras(P),
  slice(P,100001,100005,S),
  forall(R in S,(assertion(R),writeln(R))).
\end{code}

\BX
The result of extracting a slice from an infinite stream of Pythagorean triples.
\begin{codex}
?- pythagorean_slice.
184575^2+113792^2=:=216833^2
184828^2+112896^2=:=216580^2
185079^2+112000^2=:=216329^2
185328^2+111104^2=:=216080^2
true.
\end{codex}
\EX

\section{Wrappers on I/O and stateful procedural Prolog constructs}

\BI
\I e.g. a file or socket reader can be wrapped as a generator
\I event streams can be seen as generators 
\I as an example, clause/2, wrapped as an engine allows exploring a predicate in a froward loop rather then on backtracking
\EI

{\Large TODO: wrap up a file reader as an engine - maybe from the pio package?}

\section{Engines and Multithreading? - if space permits}

{\Large TODO: discuss similarities and differences, possibly show an example where engines implement cooperative multitasking or coordination}

\section{Engine Implementation Support}

{\Large TODO: discuss  SWI-Prolog's lightweight engine implementation}

\BI
\I mention also that pseudo-engines, implemented more efficiently with state
preserved with things like nb\_setarg (e.g. counters or aggregates) can be encapsulated as special instances of the engine or generator API
\I such pseudo-engines can mimic generators the same way as a C-based built-in like {\tt memberchk} emulates an equivalent Prolog definition 

\I mention also expressing a similar set of operations with OR-continuations?
\EI

\section{Discussion}



\BI
 \I efficiency - avoiding engines when possible reduces memory footprint and avoids term copying
\I no gc is needed when working destructively in constant space - but results can be exposed declaratively
\I algorithms (e.g. convolution of infinite sequences) easier to implement efficiently
\I handling big data streams -can benefit from a library of stream combinators
\EI


Reasons for some of the new things we propose:
\BI
\I what generators can bring in languages like Python \\-e.g. itertools, 
see \url{https://docs.python.org/3/library/itertools.html}
\I lazy evaluation brings to Haskell a declarative handling of infinite sequences
\I we want to add streams to
handle potentially very large amounts of data flowing over the internet
\I the need to update Prolog's language constructs to closely match new developments adopted by some of today's most successful programming languages (e.g. mention Python's yield \verb~C++~ fibers, go-language's goroutines)
\EI
enhances the expressiveness of  

\BI
\I  applications that one can think of are:
\BI
\I scanning multiple tweet streams for a common topic, 
\I finding correlations in multiple stock quote streams 
\I managing IOT signal streams
\I stream processing  can be parallelized when streams originate from things like arrays
\I interfaces to ASP or SAT - returning answers sets as streams can benefit from stream combinator operations
\I combinatorial generation tools - e.g. for for testing purposes - can be encapsulated as lazy streams
\EI
\EI

\BI
{\Large
\I generators vs. lazy list
\BI
\I one  can access the N-th element of a  generator in $P(1)$ space
\I lazy lists might or might not need $O(N)$ for the same, depending on possible garbage collection of their unused prefix
\I but, lazy lists are reusable while generators need explicit cloning
\I lazy lists operate via a convenient but {\em concrete} list syntax
\I generators represent {\em abstract} lazy sequences on which one operates directly (via a somewhat procedural API) or declaratively via an algebra encapsulated as an embedded language
\EI
}
\I {\large discuss similarities of purpose with SWI-Prolog's solution sequences API}
\I {\large can generators be combined with the {\bf tor} library \cite{tor} to make more efficient algorithms when working on infinite streams or implementing pseudo-engines?}

\I {\large is the linear logic view of generators needed or one should make the cloning operation automatic?}

\I {\large should deep cloning be computed symbolically by applying program transformation directly to the goals encapsulated by the engines?
}
\EI



\section{Related work}

\vskip 1cm
Maybe?
\BI 
\I some history - see
\cite{tarau:parimp99,tarau:cl2000,iclp08:inter,ciclops08:pINTER}
\cite{coord11tarau}
\cite{bp2011}
\I work on delimited continuations \cite{delim}, hookable disjunction \cite{tor}
\I work on pipelines \cite{pipelines}
\EI


{\Large TODO: discuss alternative ways to achieve the same in Prolog e.g. tor \cite{tor}}

{\Large TODO: briefly discuss and compare with Python and mention other generator and coroutine implementations e.g. goroutines, fibers, generator libraries for other languages etc.}

{\Large OPEN QUESTION: can a similar answer generator API be implemented
it terms of  attributed-variables, TOR, delimited continuations? That 
would avoid creating new virtual machines. A different semantics would need to
be faced: would such streams be subject to backtracking. Is that good or bad? 
} a way to do that would be to attach a goal+template as attributes of a variable
and then have the unify hook make the goal call itself with a new argument, while
extracting its "answer" in a lazy\_findall-like mechanism. Thus the simpler question becomes:
{\large can something like lazy\_findall be implemented without engines?}

{\Large related work on streams - e.g. Zaniolo, Gurevich,  Babcock}

\section{Conclusion}

Answer Stream Generators lift the expressiveness of Prolog with language constructs comparable to generators in languages like Python, go, C\verb~#~, Ruby or Lua, and language constructs implicitly available in non-strict functional programming languages like Haskell. 

They give the programmer a sequence or set abstraction that allows organizing sequence processing as AND-streams or OR-streams of answers.

Generator cloning, along the lines of similar linear logic operations, 
offers the programmer a choice between flexibility and optimal resource utilization.

The generator algebra together with its the embedded language interpreter supports
the writing compact and elegant code.
{TODO: expand}

\bibliographystyle{acmtrans}
\bibliography{theory,tarau,proglang,biblio,new}


\section*{Appendix}

{\large not to be included in the paper, added here just to make a few tests get into the Prolog file extracted from the LaTeX document}

\end{document}
